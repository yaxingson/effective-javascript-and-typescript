# effective-javascript-and-typescript

简体中文 &nbsp; | &nbsp; [英文](./README.md)

## JavaScript

### 熟悉 JavaScript

- [了解你使用的 JavaScript 版本]()
- [理解 JavaScript 的浮点数]()
- [小心隐式类型转换]()
- [优先使用原始类型而非对象包装器]()
- [避免在混合类型中使用 ==]()
- [了解分号插入的局限性]()
- [将字符串视为 16 位代码单元的序列]()

### 变量作用域

- [尽量减少全局对象的使用]()
- [始终声明局部变量]()
- [避免使用 with]()
- [熟悉闭包]()
- [理解变量提升]()
- [使用立即调用的函数表达式创建局部作用域]()
- [注意命名函数表达式的不可移植作用域]()
- [注意块级函数声明的不可移植作用域]()
- [避免使用 eval 创建局部变量]()
- [优先使用间接 eval 而非直接 eval]()

### 函数的使用

- [理解函数、方法和构造函数调用的区别]()
- [熟悉高阶函数的使用]()
- [使用 call 调用具有自定义接收器的方法]()
- [使用 apply 调用具有不同数量参数的函数]()
- [使用 arguments 创建可变参数函数]()
- [不要修改 arguments 对象]()
- [使用变量保存 arguments 的引用]()
- [使用 bind 提取具有固定接收器的方法]()
- [使用 bind 进行函数柯里化]()
- [避免依赖函数的 toString 方法]()
- [避免使用非标准的堆栈检查属性]()

### 对象和原型

- [理解 prototype、getPrototypeOf 和 __proto__ 的区别]()
- [优先使用 Object.getPrototypeOf 而非 __proto__]()
- [永远不要修改 __proto__]()
- [使你的构造函数与 new 无关]()
- [将方法存储在原型上]()
- [使用闭包存储私有数据]()
- [仅在实例对象上存储实例状态]()
- [识别 this 的隐式绑定]()
- [在子类构造函数中调用超类构造函数]()
- [不要重用超类属性名]()
- [避免继承标准类]()
- [将原型视为实现细节]()
- [避免鲁莽的猴子补丁]()

### 数组和字典

- [从 Object 的直接实例构建轻量级字典]()
- [使用 null 原型防止原型污染]()
- [使用 hasOwnProperty 防止原型污染]()
- [对于有序集合，优先使用数组而非字典]()
- [永远不要向 Object.prototype 添加可枚举属性]()
- [避免在枚举过程中修改对象]()
- [对于数组迭代，优先使用 for 循环而非 for...in 循环]()
- [优先使用迭代方法而非循环]()
- [在类数组对象上重用通用数组方法]()
- [优先使用数组字面量而非数组构造函数]()

### 库和 API 设计

- [保持一致的约定]()
- [将 undefined 视为“无值”]()
- [接受选项对象作为关键字参数]()
- [避免不必要的状态]()
- [使用结构类型实现灵活接口]()
- [区分数组和类数组]()
- [避免过度强制转换]()
- [支持方法链式调用]()

### 并发

- [不要在 I/O 上阻塞事件队列]()
- [使用嵌套或命名回调进行异步序列化]()
- [注意被丢弃的错误]()
- [使用递归进行异步循环]()
- [不要在计算上阻塞事件队列]()
- [使用计数器执行并发操作]()
- [永远不要同步调用异步回调]()
- [使用 Promise 实现更清晰的异步逻辑]()

## TypeScript

### 了解 TypeScript

- [理解 TypeScript 和 JavaScript 的关系]()
- [了解你使用的 TypeScript 选项]()
- [理解代码生成与类型无关]()
- [熟悉结构类型]()
- [限制 any 类型的使用]()

### TypeScript 的类型系统

- [使用编辑器来探索和查询类型系统]()
- [将类型视为值的集合]()
- [知道如何判断符号是在类型空间还是值空间]()
- [优先使用类型注解而非类型断言]()
- [避免使用对象包装器类型（String、Number、Boolean、Symbol、BigInt）]()
- [区分多余属性检查与类型检查]()
- [尽可能将类型应用于整个函数表达式]()
- [了解 type 和 interface 的区别]()
- [使用 readonly 避免与突变相关的错误]()
- [使用类型操作和泛型类型避免重复代码]()
- [优先使用更精确的替代方案而非索引签名]()
- [避免使用数字索引签名]()

### 类型推断和控制流分析

- [避免在代码中充斥可推断的类型]()
- [为不同类型使用不同的变量]()
- [理解变量如何获取其类型]()
- [一次性创建对象]()
- [理解类型缩小]()
- [在使用别名时保持一致]()
- [理解上下文在类型推断中的作用]()
- [理解演化类型]()
- [使用函数式结构和库帮助类型流动]()
- [使用 async 函数而非回调以改善类型流动]()
- [使用类和柯里化创建新的推断点]()

### 类型设计

- [接受时宽松，输出时严格]()
- [优先使用始终表示有效状态的类型]()
- [不要在文档中重复类型信息]()
- [避免在类型别名中包含 null 或 undefined]()
- [将 null 值推到类型的边缘]()
- [优先使用接口的联合而非联合的接口]()
- [优先使用更精确的替代方案而非字符串类型]()
- [为特殊值使用独特的类型]()
- [限制可选属性的使用]()
- [避免重复相同类型的参数]()
- [优先统一类型而非建模差异]()
- [优先使用不精确的类型而非不准确的类型]()
- [使用问题域的语言命名类型]()
- [避免基于轶事数据的类型]()

### 不健全性和 any 类型

- [将 any 类型的范围限制在最小]()
- [优先使用更精确的 any 变体而非普通的 any]()
- [将不安全的类型断言隐藏在类型良好的函数中]()
- [对于未知类型的值，使用 unknown 而非 any]()
- [优先使用类型安全的方法进行猴子补丁]()
- [避免健全性陷阱]()
- [跟踪类型覆盖率以防止类型安全性的退化]()

### 泛型和类型级编程

- [将泛型视为类型之间的函数]()
- [避免不必要的类型参数]()
- [优先使用条件类型而非重载签名]()
- [知道如何控制联合在条件类型上的分布]()
- [使用模板字面量类型建模 DSL 和字符串之间的关系]()
- [为你的类型编写测试]()
- [注意类型的显示方式]()
- [优先使用尾递归泛型类型]()
- [考虑将代码生成作为复杂类型的替代方案]()

### TypeScript 实践

- [使用 never 类型进行穷尽性检查]()
- [知道如何遍历对象]()
- [使用 Record 类型保持值同步]()
- [使用剩余参数和元组类型建模可变参数函数]()
- [使用可选的 never 属性建模异或]()
- [考虑使用品牌进行名义类型]()

### 类型声明和 @types

- [将 TypeScript 和 @types 放在 devDependencies 中]()
- [理解类型声明涉及的三个版本]()
- [导出出现在公共 API 中的所有类型]()
- [使用 TSDoc 进行 API 注释]()
- [如果 this 是回调 API 的一部分，为其提供类型]()
- [镜像类型以切断依赖]()
- [使用模块增强来改进类型]()

### 编写和运行代码

- [优先使用 ECMAScript 特性而非 TypeScript 特性]()
- [使用源映射调试 TypeScript]()
- [知道如何在运行时重建类型]()
- [理解 DOM 层次结构]()
- [创建准确的环境模型]()
- [理解类型检查与单元测试的关系]()
- [注意编译器性能]()

### 现代化和迁移

- [编写现代 JavaScript]()
- [使用 @ts-check 和 JSDoc 实验 TypeScript]()
- [使用 allowJs 混合 TypeScript 和 JavaScript]()
- [按模块逐步迁移依赖图]()
- [在启用 noImplicitAny 之前不要认为迁移完成]()
